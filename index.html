<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Helping</title>
    <style>
        div{
            padding-top: 100vh;
            
        }

        a{
            color: aquamarine;
            text-decoration: none;
        }
    </style>
</head>
<body>
    <div>

        <strong> fork</strong>
        <pre>
                #include <stdio.h>
                #include <stdlib.h>
                #include <sys/types.h>
                #include <sys/wait.h>
                #include <unistd.h>
                int main() {
                pid_t pid = fork();
                if(pid == 0) {
                printf("Child => PPID: %d PID: %d\n", getppid(), 
                getpid());
                exit(EXIT_SUCCESS);
                }
                else if(pid > 0) {
                printf("Parent => PID: %d\n", getpid());
                printf("Waiting for child process to finish.\n");
                wait(NULL);
                printf("Child process finished.\n");
                }
                else {
                printf("Unable to create child process.\n");
                }
                return EXIT_SUCCESS;
                }
        </pre>

        <strong> parentChildIPC </strong>
        <pre>
                #include<stdio.h>
                #include<unistd.h>
                int main() {
                 int pipefds[2];
                 int returnstatus;
                 int pid;
                 char writemessages[2][20]={"Divyanshu", "2019UIT3020"};
                 char readmessage[20];
                 returnstatus = pipe(pipefds);
                 if (returnstatus == -1) {
                 printf("Unable to create pipe\n");
                 return 1;
                 }
                 pid = fork();
                 printf("pid: %d \n",pid);
                 // Child process
                 if (pid == 0) {
                 read(pipefds[0], readmessage, sizeof(readmessage));
                 printf("Child Process - Reading from pipe – Message 1 is %s\n", readmessage);
                 read(pipefds[0], readmessage, sizeof(readmessage));
                 printf("Child Process - Reading from pipe – Message 2 is %s\n", readmessage);
                 } else { //Parent process
                 printf("Parent Process - Writing to pipe - Message 1 is %s\n", writemessages[0]);
                 write(pipefds[1], writemessages[0], sizeof(writemessages[0]));
                 printf("Parent Process - Writing to pipe - Message 2 is %s\n", writemessages[1]);
                 write(pipefds[1], writemessages[1], sizeof(writemessages[1]));
                 }
                 return 0;
                }
        </pre>

        <strong> twoChildIPC</strong>
        <pre>
                #include <unistd.h>
                #include <stdio.h>
                int main()
                {
                int pipefds[2];
                int returnstatus;
                char writemessages[20]="Divyanshu";
                char readmessage[20];
                returnstatus = pipe(pipefds);
                 
                 if (returnstatus == -1) {
                 printf("Unable to create pipe\n");
                 return 1;
                 }
                 // Creating first child
                int n1 = fork();
                
                if (n1 > 0) //finding parent ID
                {
                    printf("parent\n");
                    printf("n1:\t %d \n", n1);
                    printf("my id (parent) is %d \n", getpid());
                    waitpid(n1, NULL, 0);
                    // Creating second child. 
                    int n2 = fork(); 
                    if(n2==0){
                        printf("second child\n");
                        printf("n2: \t %d \n", n2);
                        printf("my id is (Second child) %d \n", getpid());
                        printf("my parentid ( for second child)is %d \n", getppid());
                        
                        read(pipefds[0], readmessage, sizeof(readmessage));
                        printf("Reading from pipe – Message 1 is %s\n", readmessage);
                    }
                    else{
                        waitpid(n2, NULL, 0);
                    }   
                
                }
                else if (n1 == 0) //child 1 writing to pipe
                {
                    printf("First child\n");
                    printf("n1:\t %d \n", n1);
                    printf("my id is (First child) %d \n", getpid());
                    printf("my parentid (for first child) is %d \n", getppid());
                    printf("Writing to pipe - Message 1 is %s\n", writemessages);
                    write(pipefds[1], writemessages, sizeof(writemessages));
                }
                
                return 0;
                }
                
        </pre>

        <strong> parentChild2way</strong>
        <pre>
                #include<stdio.h>
                #include<unistd.h>
                #include<stdlib.h>
                #include<string.h>
                int main() {
                int pipefds1[2], pipefds2[2];
                int returnstatus1, returnstatus2;
                int pid;
                char pipe1writemessage[20]; 
                char pipe2writemessage[20];
                char readmessage[20];
                returnstatus1 = pipe(pipefds1);
                
                if (returnstatus1 == -1) {
                printf("Unable to create pipe 1 \n");
                return 1;
                }
                returnstatus2 = pipe(pipefds2);
                if (returnstatus2 == -1) {
                printf("Unable to create pipe 2 \n");
                return 1;
                }
                pid = fork();
                int pip1=1;
                while(pip1) {
                if (pid != 0){
                close(pipefds1[0]);
                close(pipefds2[1]);
                
                
                printf("In Parent: Writing to pipe 1\n");
                scanf("%s",pipe1writemessage);
                printf("– Message is %s\n",pipe1writemessage); 
                if(strcmp(pipe1writemessage,"STOP")==0) break;
                
                write(pipefds1[1], pipe1writemessage, sizeof(pipe1writemessage));
                read(pipefds2[0], readmessage, sizeof(readmessage));
                printf("In Parent: Reading from pipe 2 – Message is %s\n", readmessage);
                
                } 
                
                else { //child process
                close(pipefds1[1]); // Close the unwanted pipe1 write side
                close(pipefds2[0]); // Close the unwanted pipe2 read side
                read(pipefds1[0], readmessage, sizeof(readmessage));
                printf("In Child: Reading from pipe 1 – Message is %s\n", readmessage);
                
                printf("In Child: Writing to pipe 2 \n");
                scanf("%s",pipe2writemessage);
                printf("– Message is %s\n",pipe2writemessage); 
                if(strcmp(pipe2writemessage,"STOP")==0) break;
                write(pipefds2[1], pipe2writemessage, sizeof(pipe2writemessage));
                
                }
                }
                return 0;
                }
        </pre>

        <strong>2child2way </strong>
        <pre>
            #include<stdio.h>
                #include<unistd.h>
                #include<stdlib.h>
                #include<string.h>
                int main() {
                 int pipefds1[2], pipefds2[2];
                 int returnstatus1, returnstatus2;
                 int pid;
                 char pipe1writemessage[20];
                 char pipe2writemessage[20];
                 char readmessage[20];
                 returnstatus1 = pipe(pipefds1);
                 
                 if (returnstatus1 == -1) {
                 printf("Unable to create pipe 1 \n");
                 return 1;
                 }
                 returnstatus2 = pipe(pipefds2);
                 
                 if (returnstatus2 == -1) {
                 printf("Unable to create pipe 2 \n");
                 return 1;
                 }
                 int n1 = fork();
                 int n2=fork();
                 
                 if (n1 > 0 && n2 > 0) {
                    
                 printf("parent\n");
                 printf("%d %d \n", n1, n2);
                 printf(" my id (parent) is %d \n", getpid());
                 printf("_____________________\n");
                //  waitpid(n1, NULL, 0);
                //  waitpid(n2, NULL, 0);
                 }
                 int pip1=1;
                while(pip1) {
                 if (n1> 0 && n2 ==0){ // child 2
                 printf("parent id %d\n",getppid());
                 close(pipefds1[0]); // Close the unwanted pipe1 read side
                 close(pipefds2[1]); // Close the unwanted pipe2 write side
                 
                 printf("In Child 2: Writing to pipe 1 – Message is \n");
                 scanf("%s", pipe1writemessage);
                 if(strcmp(pipe1writemessage,"STOP")==0) {
                    close(pipefds1[1]); 
                    close(pipefds2[0]); 
                    break;
                 }
                 write(pipefds1[1], pipe1writemessage, sizeof(pipe1writemessage));
                 read(pipefds2[0], readmessage, sizeof(readmessage));
                 printf("In Child 2: Reading from pipe 2 – Message is %s\n", readmessage);
                 
                 }
                 else if(n1==0 && n2>0) { //child1 process
                 printf("parent id %d\n",getppid());
                 close(pipefds1[1]); // Close the unwanted pipe1 write side
                 close(pipefds2[0]); // Close the unwanted pipe2 read side
                 read(pipefds1[0], readmessage, sizeof(readmessage));
                 printf("In Child 1: Reading from pipe 1 – Message is %s\n", readmessage);
                 printf("In Child 1: Writing to pipe 2 – Message is \n");
                 scanf("%s", pipe2writemessage);
                 if(strcmp(pipe2writemessage,"STOP")==0) {
                    close(pipefds1[0]); 
                    close(pipefds2[1]); 
                 
                    break;
                 }
                 write(pipefds2[1], pipe2writemessage, sizeof(pipe2writemessage));
                 }
                }
                 return 0;
                }
        </pre>
        <strong> FIFO user1</strong>
        <pre>
                #include <stdio.h>
                #include <string.h>
                #include <fcntl.h>
                #include <sys/stat.h>
                #include <sys/types.h>
                #include <unistd.h>
                int main()
                {
                int fd;
                // FIFO file path
                char * myfifo = "/tmp/myfifo";
                // Creating the named file(FIFO)
                // mkfifo(<pathname>, <permission>)
                mkfifo(myfifo, 0666);
                char arr1[80], arr2[80];
                while (1)
                {
                // Open FIFO for write only
                
                fd = open(myfifo, O_WRONLY);
                // Take an input arr2ing from user.
                // 80 is maximum length
                fgets(arr2, 80, stdin);
                // Write the input arr2ing on FIFO
                // and close it
                
                if(strlen(arr2)>=4 && arr2[0]=='S'&& arr2[1]=='T' && arr2[2]=='O' && arr2[3]=='P') {
                    return 0;
                }
                write(fd, arr2, strlen(arr2)+1);
                close(fd);
                
                // Open FIFO for Read only
                fd = open(myfifo, O_RDONLY);
                // Read from FIFO
                read(fd, arr1, sizeof(arr1));
                // Print the read message
                printf("User2: %s\n", arr1);
                close(fd);
                }
                return 0;
                }
                
        </pre>
        <strong> FIFO user2 </strong>
        <pre>
                #include <stdio.h>
                #include <string.h>
                #include <fcntl.h>
                #include <sys/stat.h>
                #include <sys/types.h>
                #include <unistd.h>
                int main()
                {
                int fd1;
                // FIFO file path
                char * myfifo = "/tmp/myfifo";
                // Creating the named file(FIFO)
                // mkfifo(<pathname>,<permission>)
                mkfifo(myfifo, 0666);
                char str1[80], str2[80];
                while (1)
                {
                // First open in read only and read
                
                fd1 = open(myfifo,O_RDONLY);
                read(fd1, str1, 80);
                // Print the read string and close
                printf("User1: %s\n", str1);
                close(fd1);
                // Now open in write mode and write
                // string taken from user.
                fd1 = open(myfifo,O_WRONLY);
                fgets(str2, 80, stdin);
                if(strlen(str2)>=4 && str2[0]=='S'&& str2[1]=='T' && str2[2]=='O' && str2[3]=='P') {
                    return 0;
                }
                write(fd1, str2, strlen(str2)+1);
                close(fd1);
                }
                return 0;
                }
        </pre>
        <strong> Message Queue reader</strong>
        <pre>
            // C Program for Message Queue (Reader Process)
            #include <stdio.h>
            #include <sys/ipc.h>
            #include <sys/msg.h>
            // structure for message queue
            struct mesg_buffer {
            long mesg_type;
            char mesg_text[100];
            } message;
            int main()
            {
            key_t key;
            int msgid;
            // ftok to generate unique key
            key = ftok("progfile", 65);
            // msgget creates a message queue
            // and returns identifier
            msgid = msgget(key, 0666 | IPC_CREAT);
            // msgrcv to receive message

            msgrcv(msgid, &message, sizeof(message), 1, 0);
            // display the message
            printf("Data Received is : %s \n",
            message.mesg_text);
            // to destroy the message queue
            msgctl(msgid, IPC_RMID, NULL);
            return 0;
            }
        </pre>
        <strong> Message Queue Writer</strong>
        <pre>
                #include <stdio.h>
                #include <sys/ipc.h>
                #include <sys/msg.h>
                #define MAX 10
                // structure for message queue
                struct mesg_buffer {
                long mesg_type;
                char mesg_text[100];
                } message;
                int main()
                {
                key_t key;
                int msgid;
                
                // ftok to generate unique key
                key = ftok("progfile", 65);
                // msgget creates a message queue
                // and returns identifier
                msgid = msgget(key, 0666 | IPC_CREAT);
                message.mesg_type = 1;
                printf("Write Data : ");
                fgets(message.mesg_text,MAX,stdin);
                // msgsnd to send message
                msgsnd(msgid, &message, sizeof(message), 0);
                // display the message
                printf("Data send is : %s \n", message.mesg_text);
                return 0;
                }
        </pre>

        <strong>client Socket </strong>
        <pre>
            #include <arpa/inet.h>
            #include <stdio.h>
            #include <string.h>
            #include <sys/socket.h>
            #include <unistd.h>
            #define PORT 8080
            
            int main(int argc, char const* argv[])
            {
                int sock = 0, valread, client_fd;
                struct sockaddr_in serv_addr;
                printf("Enter Message from Client: \t");
                char clientMessage[80];
                scanf("%s",clientMessage);

                char buffer[1024] = { 0 };
                if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
                    printf("\n Socket creation error \n");
                    return -1;
                }
            
                serv_addr.sin_family = AF_INET;
                serv_addr.sin_port = htons(PORT);
            
                // Convert IPv4 and IPv6 addresses from text to binary
                // form
                if (inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr)
                    <= 0) {
                    printf(
                        "\nInvalid address/ Address not supported \n");
                    return -1;
                }
            
                if ((client_fd
                    = connect(sock, (struct sockaddr*)&serv_addr,
                            sizeof(serv_addr)))
                    < 0) {
                    printf("\nConnection Failed \n");
                    return -1;
                }
                send(sock, clientMessage, strlen(clientMessage), 0);
                printf("Client message sent\n");
                valread = read(sock, buffer, 1024);
                printf("Message from server: %s\n", buffer);
            
                // closing the connected socket
                close(client_fd);
                return 0;
            }
        </pre>

        <strong>Socket Server </strong>
        <pre>
            #include <netinet/in.h>
        #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        #include <sys/socket.h>
        #include <unistd.h>
        #define PORT 8080
        int main(int argc, char const* argv[])
        {
            int server_fd, new_socket, valread;
            struct sockaddr_in address;
            int opt = 1;
            int addrlen = sizeof(address);
            char buffer[1024] = { 0 };
            char serverMessage[80];
            printf("Enter Message from Server: \t");
            scanf("%s",serverMessage);


        
            // Creating socket file descriptor
            if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
                perror("socket failed");
                exit(EXIT_FAILURE);
            }
        
            // Forcefully attaching socket to the port 8080
            if (setsockopt(server_fd, SOL_SOCKET,
                        SO_REUSEADDR | SO_REUSEPORT, &opt,
                        sizeof(opt))) {
                perror("setsockopt");
                exit(EXIT_FAILURE);
            }
            address.sin_family = AF_INET;
            address.sin_addr.s_addr = INADDR_ANY;
            address.sin_port = htons(PORT);
        
            // Forcefully attaching socket to the port 8080
            if (bind(server_fd, (struct sockaddr*)&address,
                    sizeof(address))
                < 0) {
                perror("bind failed");
                exit(EXIT_FAILURE);
            }
            if (listen(server_fd, 3) < 0) {
                perror("listen");
                exit(EXIT_FAILURE);
            }
            if ((new_socket
                = accept(server_fd, (struct sockaddr*)&address,
                        (socklen_t*)&addrlen))
                < 0) {
                perror("accept");
                exit(EXIT_FAILURE);
            }
            valread = read(new_socket, buffer, 1024);
            printf("Message from client: %s\n", buffer);
            send(new_socket, serverMessage, strlen(serverMessage), 0);
            printf("Server message sent\n");
        
            // closing the connected socket
            close(new_socket);
            // closing the listening socket
            shutdown(server_fd, SHUT_RDWR);
            return 0;
        }
        </pre>
        
        <strong>Socket Multiple Server </strong>
        <pre>
            //Example code: A simple server side code, which echos back the received message.
            //Handle multiple socket connections with select and fd_set on Linux 
            #include <stdio.h> 
            #include <string.h>   //strlen 
            #include <stdlib.h> 
            #include <errno.h> 
            #include <unistd.h>   //close 
            #include <arpa/inet.h>    //close 
            #include <sys/types.h> 
            #include <sys/socket.h> 
            #include <netinet/in.h> 
            #include <sys/time.h> //FD_SET, FD_ISSET, FD_ZERO macros 
                
            #define TRUE   1 
            #define FALSE  0 
            #define PORT 8080 
                
            int main(int argc , char *argv[])  
            {  
                int opt = TRUE;  
                int master_socket , addrlen , new_socket , client_socket[30] , 
                    max_clients = 30 , activity, i , valread , sd;  
                int max_sd;  
                struct sockaddr_in address;  
                    
                char buffer[1025];  //data buffer of 1K 
                    
                //set of socket descriptors 
                fd_set readfds;  
                    
                //a message 
                char *message = "ECHO Daemon v1.0 \r\n";  
                
                //initialise all client_socket[] to 0 so not checked 
                for (i = 0; i < max_clients; i++)  
                {  
                    client_socket[i] = 0;  
                }  
                    
                //create a master socket 
                if( (master_socket = socket(AF_INET , SOCK_STREAM , 0)) < 0)  
                {  
                    perror("socket failed");  
                    exit(EXIT_FAILURE);  
                }  
                
                //set master socket to allow multiple connections , 
                //this is just a good habit, it will work without this 
                if( setsockopt(master_socket, SOL_SOCKET, SO_REUSEADDR, (char *)&opt, 
                    sizeof(opt)) < 0 )  
                {  
                    perror("setsockopt");  
                    exit(EXIT_FAILURE);  
                }  
                
                //type of socket created 
                address.sin_family = AF_INET;  
                address.sin_addr.s_addr = INADDR_ANY;  
                address.sin_port = htons( PORT );  
                    
                //bind the socket to localhost port 8888 
                if (bind(master_socket, (struct sockaddr *)&address, sizeof(address))<0)  
                {  
                    perror("bind failed");  
                    exit(EXIT_FAILURE);  
                }  
                printf("Listener on port %d \n", PORT);  
                    
                //try to specify maximum of 3 pending connections for the master socket 
                if (listen(master_socket, 3) < 0)  
                {  
                    perror("listen");  
                    exit(EXIT_FAILURE);  
                }  
                    
                //accept the incoming connection 
                addrlen = sizeof(address);  
                puts("Waiting for connections ...");  
                    
                while(TRUE)  
                {  
                    //clear the socket set 
                    FD_ZERO(&readfds);  
                
                    //add master socket to set 
                    FD_SET(master_socket, &readfds);  
                    max_sd = master_socket;  
                        
                    //add child sockets to set 
                    for ( i = 0 ; i < max_clients ; i++)  
                    {  
                        //socket descriptor 
                        sd = client_socket[i];  
                            
                        //if valid socket descriptor then add to read list 
                        if(sd > 0)  
                            FD_SET( sd , &readfds);  
                            
                        //highest file descriptor number, need it for the select function 
                        if(sd > max_sd)  
                            max_sd = sd;  
                    }  
                
                    //wait for an activity on one of the sockets , timeout is NULL , 
                    //so wait indefinitely 
                    activity = select( max_sd + 1 , &readfds , NULL , NULL , NULL);  
                
                    if ((activity < 0) && (errno!=EINTR))  
                    {  
                        printf("select error");  
                    }  
                        
                    //If something happened on the master socket , 
                    //then its an incoming connection 
                    if (FD_ISSET(master_socket, &readfds))  
                    {  
                        if ((new_socket = accept(master_socket, 
                                (struct sockaddr *)&address, (socklen_t*)&addrlen))<0)  
                        {  
                            perror("accept");  
                            exit(EXIT_FAILURE);  
                        }  
                        
                        //inform user of socket number - used in send and receive commands 
                        printf("New connection , socket fd is %d , ip is : %s , port : %d \n" , new_socket , inet_ntoa(address.sin_addr), ntohs(address.sin_port));  
                    
                        //send new connection greeting message 
                        if( send(new_socket, message, strlen(message), 0) != strlen(message) )  
                        {  
                            perror("send");  
                        }  
                            
                        puts("Welcome message sent successfully");  
                            
                        //add new socket to array of sockets 
                        for (i = 0; i < max_clients; i++)  
                        {  
                            //if position is empty 
                            if( client_socket[i] == 0 )  
                            {  
                                client_socket[i] = new_socket;  
                                printf("Adding to list of sockets as %d\n" , i);  
                                    
                                break;  
                            }  
                        }  
                    }  
                        
                    //else its some IO operation on some other socket
                    for (i = 0; i < max_clients; i++)  
                    {  
                        sd = client_socket[i];  
                            
                        if (FD_ISSET( sd , &readfds))  
                        {  
                            //Check if it was for closing , and also read the 
                            //incoming message 
                            if ((valread = read( sd , buffer, 1024)) == 0)  
                            {  
                                //Somebody disconnected , get his details and print 
                                getpeername(sd , (struct sockaddr*)&address , \
                                    (socklen_t*)&addrlen);  
                                printf("Host disconnected , ip %s , port %d \n" , 
                                    inet_ntoa(address.sin_addr) , ntohs(address.sin_port));  
                                    
                                //Close the socket and mark as 0 in list for reuse 
                                close( sd );  
                                client_socket[i] = 0;  
                            }  
                                
                            //Echo back the message that came in 
                            else 
                            {  
                                //set the string terminating NULL byte on the end 
                                //of the data read 
                                buffer[valread] = '\0';  
                                send(sd , buffer , strlen(buffer) , 0 );  
                            }  
                        }  
                    }  
                }  
                    
                return 0;  
            }  

        </pre>

        <strong> RPC </strong>
        <pre>
            IDL
            /* This is the IDL file -- name it as add.x*/

            /*combine the arguments to be passed to the server side in a structure*/
            struct numbers{
                int a;
                int b;
            };

            program ADD_PROG{
            version ADD_VERS{
                int add(numbers)=1;
            }=1;
            }=0x4562877;

            compile IDL : -$ rpcgen -a -C add.x

            Correct Makefile:
            CFLAGS += -I/usr/include/tirpc 
            LDLIBS += -ltirpc

            edit add.h

            #include "add.h"

            int *
            add_1_svc(numbers *argp, struct svc_req *rqstp)
            {
                static int  result;
                    --printf("add(%d,%d) is called\n",argp->a,argp->b);
                    --result = argp->a + argp->b;
                return &result;
            }



            edit add_client.h:

            #include "add.h"

            void
            add_prog_1(char *host,int x,int y)
            {
                CLIENT *clnt;
                int  *result_1;
                numbers  add_1_arg;

            #ifndef	DEBUG
                clnt = clnt_create (host, ADD_PROG, ADD_VERS, "udp");
                if (clnt == NULL) {
                    clnt_pcreateerror (host);
                    exit (1);
                }
            #endif	/* DEBUG */
                   -- add_1_arg.a=x;
                   -- add_1_arg.b=y;
                result_1 = add_1(&add_1_arg, clnt);
                if (result_1 == (int *) NULL) {
                    clnt_perror (clnt, "call failed");
                }
                   -- else{
                   -- printf("Result:%d\n", *result_1 );
                   -- }
            #ifndef	DEBUG
                clnt_destroy (clnt);
            #endif	 /* DEBUG */
            }


            int
            main (int argc, char *argv[])
            {
                char *host;
<!-- argument increased cuz client me client, localhost ke sath 2 aur input le rhe hai -->
               -- if (argc < 4) {
                    printf ("usage: %s server_host\n", argv[0]);
                    exit (1);
                }
                host = argv[1];
                <!-- taking input --></4>
                add_prog_1 (host,atoi(argv[2]),atoi(argv[3]));
            exit (0);
            }


            Compile: -$ make -f Makefile.add

            To start server -->    :-$ sudo ./add_server 
            To start client -->    :-$ sudo ./add_client localhost 5 8
        </pre>


        <strong> Outlier Detection</strong>
        <pre>

            # -*- coding: utf-8 -*-
            import pandas as pd
            
            df = pd.read_csv("../banknote.csv")
            
            df.head()
            
            """# New Section"""
            
            import seaborn as sns
            import matplotlib.pyplot as plt
            sns.boxplot(data=df,x=df["Length"])
            plt.title("Boxplot of Swiss Banknote Length")
            
            def boxplot(column):
                sns.boxplot(data=df,x=df[f"{column}"])
                plt.title(f"Boxplot of Swiss Banknote {column}")
                plt.show()
            
            boxplot('Length')
            boxplot('Right')
            boxplot('Left')
            boxplot('Bottom')
            boxplot('Top')
            boxplot('Diagonal')
            
            

        </pre>
        <strong>Classification KNN</strong>
        <pre>

            import numpy as np
            import pandas as pd
            
            from sklearn.datasets import load_iris
            li = load_iris()
            li
            
            X = pd.DataFrame(li['data'],columns=li['feature_names'])
            print(X.head())
            
            target = pd.DataFrame(li['target'],columns=['iris'])
            y = target['iris']
            y.value_counts()
            
            from sklearn.model_selection import train_test_split
            X_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.2)
            
            from sklearn.neighbors import KNeighborsClassifier
            clf = KNeighborsClassifier(n_neighbors=3)
            clf.fit(X_train,y_train)
            
            y_pred = clf.predict(X_test)
            
            print(clf.score(X_test,y_test))
            
            


        </pre>
        <strong>KNN</strong>
        <pre>

            from sklearn.neighbors import KNeighborsClassifier
            from sklearn.model_selection import train_test_split
            from sklearn.datasets import load_iris
            import pandas as pd
            import numpy as np
            
            irisData = load_iris()
            
            X = pd.DataFrame(data = irisData.data)
            target = pd.DataFrame(irisData['target'],columns=['iris'])
            y = target['iris']
            
            X.head()
            
            y.value_counts()
            
            np.random.seed(5)
            
            from sklearn.model_selection import train_test_split
            X_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.2)
            
            knn = KNeighborsClassifier(n_neighbors=7)
              
            knn.fit(X_train, y_train)
            
            y_pred = knn.predict(X_test)
            
            y_pred
            
            knn.score(X_test,y_test)
            
            
            
            neighbors = np.arange(1, 9)
            train_accuracy = np.empty(len(neighbors))
            test_accuracy = np.empty(len(neighbors))
            
            for i, k in enumerate(neighbors):
                knn = KNeighborsClassifier(n_neighbors=k)
                knn.fit(X_train, y_train)
                  
                # Compute training and test data accuracy
                train_accuracy[i] = knn.score(X_train, y_train)
                test_accuracy[i] = knn.score(X_test, y_test)
            
            import matplotlib.pyplot as plt
            plt.plot(neighbors, test_accuracy, label = 'Testing dataset Accuracy')
            plt.plot(neighbors, train_accuracy, label = 'Training dataset Accuracy')
              
            plt.legend()
            plt.xlabel('n_neighbors')
            plt.ylabel('Accuracy')
            plt.show()
            
            
        </pre>



        <strong>k means</strong>
        <pre>
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

dataset = pd.read_csv('https://raw.githubusercontent.com/mahesh147/KMeans-Clustering/master/Mall_Customers.csv')

dataset.head()

X = dataset.iloc[:,[3,4]].values

from sklearn.cluster import KMeans
wcss =[]
for i in range (1,11):
    kmeans = KMeans(n_clusters = i, init = 'k-means++', max_iter =300, n_init = 10, random_state = 0)
    kmeans.fit(X)
    wcss.append(kmeans.inertia_)

plt.plot(range(1,11),wcss)
plt.title('The Elbow Method')
plt.xlabel('Number of clusters')
plt.ylabel('WCSS')
plt.show()

kmeans=KMeans(n_clusters= 5, init = 'k-means++', max_iter = 300, n_init = 10, random_state = 0)
Y_Kmeans = kmeans.fit_predict(X)

plt.scatter(X[Y_Kmeans == 0, 0], X[Y_Kmeans == 0,1],s = 100, c='red', label = 'Cluster 1')

plt.scatter(X[Y_Kmeans == 1, 0], X[Y_Kmeans == 1,1],s = 100, c='blue', label = 'Cluster 2')

plt.scatter(X[Y_Kmeans == 2, 0], X[Y_Kmeans == 2,1],s = 100, c='green', label = 'Cluster 3')

plt.scatter(X[Y_Kmeans == 3, 0], X[Y_Kmeans == 3,1],s = 100, c='cyan', label = 'Cluster 4')

plt.scatter(X[Y_Kmeans == 4, 0], X[Y_Kmeans == 4,1],s = 100, c='magenta', label = 'Cluster 5')

plt.scatter(kmeans.cluster_centers_[:,0], kmeans.cluster_centers_[:,1], s = 300, c = 'yellow', label = 'Centroids')

plt.title('Clusters of clients')
plt.xlabel('Annual Income (k$)')
plt.ylabel('Spending score (1-100)')
plt.legend()
plt.show()


        </pre>
        
        <strong>Collaborative Movie Recommender</strong>
        <pre>
            # -*- coding: utf-8 -*-

            import pandas as pd
            import numpy as np
            
            df = pd.DataFrame({'Divyanshu':[0,3,0,5,0,0,4,5,0,2], 'Tej':[0,0,3,2,5,0,4,0,3,0], 'Tushar':[3,1,0,3,5,0,0,4,0,0], 'Sneha':[4,3,4,2,0,0,0,2,0,0], 
                               'Aasritha':[2,0,0,4,0,4,4,3,5,0], 'Varin':[1,0,2,4,5,0,4,0,5,0], 'Varsneya':[2,0,0,3,0,4,3,3,0,0], 'Ishika':[0,0,0,3,0,2,4,3,4,0], 
                               'Naman':[5,0,0,0,5,3,0,3,0,4], 'Vishal':[1,0,2,0,4,0,4,3,0,0]}, 
                              index=['Avatar','Iron Man','Life of Pi','Avengers','Harry Potter','Memento','Inception','Dragonfly','Shaolin Soccer','Ip man'])
            df
            
            df.values
            
            from sklearn.neighbors import NearestNeighbors
            knn = NearestNeighbors(metric='cosine', algorithm='brute')
            knn.fit(df.values)
            distances, indices = knn.kneighbors(df.values, n_neighbors=3)
            
            indices
            
            distances
            
            for title in df.index:
            
              index_user_likes = df.index.tolist().index(title) # get an index for a movie
              sim_movies = indices[index_user_likes].tolist() # make list for similar movies
              movie_distances = distances[index_user_likes].tolist() # the list for distances of similar movies
              id_movie = sim_movies.index(index_user_likes) # get the position of the movie itself in indices and distances
            
              print('Similar Movies to '+str(df.index[index_user_likes])+':\n')
            
            
              sim_movies.remove(index_user_likes) # remove the movie itself in indices
              movie_distances.pop(id_movie) # remove the movie itself in distances
            
              j = 1
              
              for i in sim_movies:
                print(str(j)+': '+str(df.index[i])+', the distance with '+str(title)+': '+str(movie_distances[j-1]))
                j = j + 1
                  
              print('\n')
            
            
            
            """# Recommend Similar movies to selected movie"""
            
            def recommend_movie(title):
            
              index_user_likes = df.index.tolist().index(title) # get an index for a movie
              sim_movies = indices[index_user_likes].tolist() # make list for similar movies
              movie_distances = distances[index_user_likes].tolist() # the list for distances of similar movies
              id_movie = sim_movies.index(index_user_likes) # get the position of the movie itself in indices and distances
            
              print('Similar Movies to '+str(df.index[index_user_likes])+': \n')
            
              sim_movies.remove(index_user_likes) # remove the movie itself in indices
              movie_distances.pop(id_movie) # remove the movie itself in distances
            
              j = 1
                
              for i in sim_movies:
                print(str(j)+': '+str(df.index[i])+', the distance with '+str(title)+': '+str(movie_distances[j-1]))
                j = j + 1
            
            recommend_movie('Inception')
            
            
            
            """# Recommend Similar movie to selected User"""
            
            knn = NearestNeighbors(metric='cosine', algorithm='brute')
            knn.fit(df.values)
            distances, indices = knn.kneighbors(df.values, n_neighbors=3)
            
            index_for_movie = df.index.tolist().index('Avengers') # it returns 0
            sim_movies = indices[index_for_movie].tolist() # make list for similar movies
            movie_distances = distances[index_for_movie].tolist() # the list for distances of similar movies
            id_movie = sim_movies.index(index_for_movie) # get the position of the movie itself in indices and distances
            sim_movies.remove(index_for_movie) # remove the movie itself in indices
            movie_distances.pop(id_movie) # remove the movie itself in distances
            
            print('The Nearest Movies to Avatar:', sim_movies)
            print('The Distance from Avatar:', movie_distances)
            
            movie_similarity = [-x+1 for x in movie_distances] # inverse distance 
            
            predicted_rating = (movie_similarity[0]*df.iloc[sim_movies[0],7] + movie_similarity[1]*df.iloc[sim_movies[1],7])/sum(movie_similarity)
            print(predicted_rating)
            
            
            
            """# Building a recommender"""
            
            # find the nearest neighbors using NearestNeighbors(n_neighbors=3)
            number_neighbors = 3
            knn = NearestNeighbors(metric='cosine', algorithm='brute')
            knn.fit(df.values)
            distances, indices = knn.kneighbors(df.values, n_neighbors=number_neighbors)
            
            # copy df
            df1 = df.copy()
            
            # convert user_name to user_index
            user_index = df.columns.tolist().index('Divyanshu')
            
            # t: movie_title, m: the row number of t in df
            for m,t in list(enumerate(df.index)):
              
              # find movies without ratings by user_4
              if df.iloc[m, user_index] == 0:
                sim_movies = indices[m].tolist()
                movie_distances = distances[m].tolist()
                
                # Generally, this is the case: indices[3] = [3 6 7]. The movie itself is in the first place.
                # In this case, we take off 3 from the list. Then, indices[3] == [6 7] to have the nearest NEIGHBORS in the list. 
                if m in sim_movies:
                  id_movie = sim_movies.index(m)
                  sim_movies.remove(m)
                  movie_distances.pop(id_movie) 
            
                # However, if the percentage of ratings in the dataset is very low, there are too many 0s in the dataset. 
                # Some movies have all 0 ratings and the movies with all 0s are considered the same movies by NearestNeighbors(). 
                # Then,even the movie itself cannot be included in the indices. 
                # For example, indices[3] = [2 4 7] is possible if movie_2, movie_3, movie_4, and movie_7 have all 0s for their ratings.
                # In that case, we take off the farthest movie in the list. Therefore, 7 is taken off from the list, then indices[3] == [2 4].
                else:
                  sim_movies = sim_movies[:number_neighbors-1]
                  movie_distances = movie_distances[:number_neighbors-1]
                    
                  # movie_similarty = 1 - movie_distance    
                movie_similarity = [1-x for x in movie_distances]
                movie_similarity_copy = movie_similarity.copy()
                nominator = 0
            
                # for each similar movie
                for s in range(0, len(movie_similarity)):
                  
                  # check if the rating of a similar movie is zero
                  if df.iloc[sim_movies[s], user_index] == 0:
            
                    # if the rating is zero, ignore the rating and the similarity in calculating the predicted rating
                    if len(movie_similarity_copy) == (number_neighbors - 1):
                      movie_similarity_copy.pop(s)
                      
                    else:
                      movie_similarity_copy.pop(s-(len(movie_similarity)-len(movie_similarity_copy)))
            
                  # if the rating is not zero, use the rating and similarity in the calculation
                  else:
                    nominator = nominator + movie_similarity[s]*df.iloc[sim_movies[s],user_index]
            
                # check if the number of the ratings with non-zero is positive
                if len(movie_similarity_copy) > 0:
                  
                  # check if the sum of the ratings of the similar movies is positive.
                  if sum(movie_similarity_copy) > 0:
                    predicted_r = nominator/sum(movie_similarity_copy)
            
                  # Even if there are some movies for which the ratings are positive, some movies have zero similarity even though they are selected as similar movies.
                  # in this case, the predicted rating becomes zero as well  
                  else:
                    predicted_r = 0
                # if all the ratings of the similar movies are zero, then predicted rating should be zero
                else:
                  predicted_r = 0
            
              # place the predicted rating into the copy of the original dataset
                df1.iloc[m,user_index] = predicted_r
            
            def recommend_movies(user, num_recommended_movies):
            
              print('The list of the Movies {} Has Watched \n'.format(user))
            
              for m in df[df[user] > 0][user].index.tolist():
                print(m)
              
              print('\n')
            
              recommended_movies = []
            
              for m in df[df[user] == 0].index.tolist():
            
                index_df = df.index.tolist().index(m)
                predicted_rating = df1.iloc[index_df, df1.columns.tolist().index(user)]
                recommended_movies.append((m, predicted_rating))
            
              sorted_rm = sorted(recommended_movies, key=lambda x:x[1], reverse=True)
              
              print('The list of the Recommended Movies \n')
              rank = 1
              for recommended_movie in sorted_rm[:num_recommended_movies]:
                
                print('{}: {} - predicted rating:{}'.format(rank, recommended_movie[0], recommended_movie[1]))
                rank = rank + 1
            
            recommend_movies('Divyanshu',5)
            
            df1 = df.copy()
            
            def movie_recommender(user, num_neighbors, num_recommendation):
              
              number_neighbors = num_neighbors
            
              knn = NearestNeighbors(metric='cosine', algorithm='brute')
              knn.fit(df.values)
              distances, indices = knn.kneighbors(df.values, n_neighbors=number_neighbors)
            
              user_index = df.columns.tolist().index(user)
            
              for m,t in list(enumerate(df.index)):
                if df.iloc[m, user_index] == 0:
                  sim_movies = indices[m].tolist()
                  movie_distances = distances[m].tolist()
                
                  if m in sim_movies:
                    id_movie = sim_movies.index(m)
                    sim_movies.remove(m)
                    movie_distances.pop(id_movie) 
            
                  else:
                    sim_movies = sim_movies[:num_neighbors-1]
                    movie_distances = movie_distances[:num_neighbors-1]
                       
                  movie_similarity = [1-x for x in movie_distances]
                  movie_similarity_copy = movie_similarity.copy()
                  nominator = 0
            
                  for s in range(0, len(movie_similarity)):
                    if df.iloc[sim_movies[s], user_index] == 0:
                      if len(movie_similarity_copy) == (number_neighbors - 1):
                        movie_similarity_copy.pop(s)
                      else:
                        movie_similarity_copy.pop(s-(len(movie_similarity)-len(movie_similarity_copy)))
                        
                    else:
                      nominator = nominator + movie_similarity[s]*df.iloc[sim_movies[s],user_index]
                      
                  if len(movie_similarity_copy) > 0:
                    if sum(movie_similarity_copy) > 0:
                      predicted_r = nominator/sum(movie_similarity_copy)
                    
                    else:
                      predicted_r = 0
            
                  else:
                    predicted_r = 0
                    
                  df1.iloc[m,user_index] = predicted_r
              recommend_movies(user,num_recommendation)
            
            movie_recommender('Divyanshu', 4, 5)
            
            




        </pre>
        <a href="./public/resources/ANN.pdf">ANN sem 6</a>
        <li>
            <a href="https://drive.google.com/drive/folders/1dwxWAWVA6O-Nct4N23eAfmAQlL0NHUGo">Tej</a>
        </li>
        <a href="./tuhsar_notes.html">Tushar Notes</a>
    
        
        <pre>
        #include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

#define PERMS 0644
struct my_msgbuf {
   long mtype;
   char mtext[200];
};

int main(void) {
   struct my_msgbuf buf;
   int msqid;
   int len;
   key_t key;
   system("touch msgq.txt");
   
   if ((key = ftok("msgq.txt", 'B')) == -1) {
      perror("ftok");
      exit(1);
   }
   
   if ((msqid = msgget(key, PERMS | IPC_CREAT)) == -1) {
      perror("msgget");
      exit(1);
   }
   printf("message queue: ready to send messages.\n");
   printf("Enter lines of text, ^D to quit:\n");
   buf.mtype = 1; /* we don't really care in this case */
   int sum=100;
   
   while(sum>10) {

    int arr[10];
    pritnf("Enter Numbers in the array \n");
    for(int i=0; i<10; i++){
        printf("%d: ", i+1);
        scanf("%d",&arr[i]);
        printf("\n");
    }
    int sum=0;
    for(int i=0; i<10; i++){
        sum+=arr[i];
    }

    sum/=10;
    printf("Sum divided by 10: \"%d\" ",sum);
    if(sum<10)
    {
        printf("Less than 10, stopping the communication\n");
        break;
    }
      len = strlen(buf.mtext);
      /* remove newline at end, if it exists */
      if (buf.mtext[len-1] == '\n') buf.mtext[len-1] = '\0';
      if (msgsnd(msqid, &buf, len+1, 0) == -1) /* +1 for '\0' */
      perror("msgsnd");
   }
   strcpy(buf.mtext, "end");
   len = strlen(buf.mtext);
   if (msgsnd(msqid, &buf, len+1, 0) == -1) /* +1 for '\0' */
   perror("msgsnd");
   
   if (msgctl(msqid, IPC_RMID, NULL) == -1) {
      perror("msgctl");
      exit(1);
   }
   printf("message queue: done sending messages.\n");
   return 0;
}
        </pre>
        
        #include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include<string.h>

#define PERMS 0644
struct my_msgbuf {
   long mtype;
   char mtext[200];
};

int main(void) {
   struct my_msgbuf buf;
   int msqid;
   int toend;
   key_t key;
   
   if ((key = ftok("msgq.txt", 'B')) == -1) {
      perror("ftok");
      exit(1);
   }
   
   if ((msqid = msgget(key, PERMS)) == -1) { /* connect to the queue */
      perror("msgget");
      exit(1);
   }
   printf("message queue: ready to receive messages.\n");
   
   for(;;) { /* normally receiving never ends but just to make conclusion 
             /* this program ends wuth string of end */
      if (msgrcv(msqid, &buf, sizeof(buf.mtext), 0, 0) == -1) {
         perror("msgrcv");
         exit(1);
      }
      printf("recvd: \"%s\"\n", buf.mtext);
      toend = strcmp(buf.mtext,"end");
      if (toend == 0)
      break;
   }
   printf("message queue: done receiving messages.\n");
   system("rm msgq.txt");
   return 0;
}
        
        
        <pre>
        
        
        
        
        
        </pre>
        
<strong>HEBB</strong>
<pre>
print("\n")
def printable(x1,x2,bias,y):
    print("\t\tAND GATE logic Table")
    print("__________________________________________________________")
    print("| ","X1","\t|\t ","X2","\t|\t ","b","\t |\t","Y \t|")
    print("________________________________________________________")
    for i in range(4):
        print("| ",x1[i],"\t|\t ",x2[i],"\t|\t ",bias[i],"\t |\t",y[i],"\t|")
        print("________________________________________________________")

x1=[1,-1,1,-1]
x2=[1,1,-1,-1]
bias=[1,1,1,1]
y=[1,-1,-1,-1]

printable(x1,x2,bias,y)
w1=0
w2=0
b=0

print("\n\n")
print("\t\t\t\t HEBB LEARNING RULE TABLE")
print()
print("| ","X1","\t|\t ","X2","\t|\t ","bias","\t |\t","Y \t|","w1","\t|\t ","w2","\t|\t ","b","\t|\t ")
print("_________________________________________________________________________________________________________________")
for i in range(4):
    w1 = w1 + x1[i]*y[i]
    w2= w2+ x2[i]*y[i]

    b=b+y[i]

    print("| ",x1[i],"\t|\t ",x2[i],"\t|\t ",bias[i],"\t |\t",y[i],"\t|",w1,"\t|\t ",w2,"\t|\t ",b,"\t|\t ")
    print("__________________________________________________________________________________________________________________")


</pre>

<hr>
<br>

<strong>MCP OR</strong>
<pre>
    class MpNeuron:
  inpOuts = []

  def addinpOuput(self, inp, out):
    self.inpOuts.append([inp, out])

  def getNetinp(self, inp, weights):
    netinp = 0
    for i in range(len(inp)):
      netinp += inp[i] * weights[i]
    return netinp

  def getValidThreshold(self, weights):
    threshold = 10000000

    for inp, out in self.inpOuts:
      if out == 1:
        threshold = min(threshold, self.getNetinp(inp, weights))

    for inp, out in self.inpOuts:
      if out == 0 and threshold <= self.getNetinp(inp, weights):
        return None

    return threshold


orNeuron = MpNeuron()
orNeuron.addinpOuput([0, 0], 0)
orNeuron.addinpOuput([0, 1], 1)
orNeuron.addinpOuput([1, 0], 1)
orNeuron.addinpOuput([1, 1], 1)

print('Or Gate\'s Truth Table: ')
print('x1 x2 y')
print('-------')
print('0  0  0')
print('0  1  1')
print('1  0  1')
print('1  1  1')
print()

while True:
  weights = list(map(int, input('Enter weights: ').split(' ')))
  threshold = orNeuron.getValidThreshold(weights)

  if threshold != None:
    print('Weights are correct, Threshold Found:', threshold)
    print('Hence, and gate can be realised using mp neuron')
    break
  else:
    print('Invalid weights')
    print()

</pre>
        
<hr>
<br>

<strong>MCP XOR</strong>
<pre>

    def f(yin,theta):
    if yin >= theta: 
        return 1
    else:
        return 0

def makeGate(gateName,first,op,second,x1Header,x2Header,yHeader,yinHeader,w1,w2,theta):
    print()
    print(gateName," gate => ",yHeader," = ",first,op,second)
    
    print("We take w1 = ",w1," and w2 = ",w2)
    print()
    
    x1 = [1,1,0,0]
    x2 = [1,0,1,0]
    y = []
    
    # calculate y
    for i in range(0,4):
        if first[0] != "~" and second[0] != "~" and op == "|":
            ans = x1[i] | x2[i]
            
        elif first[0] != "~" and second[0] != "~" and op == "&":
            ans = x1[i] & x2[i]
            
        elif first[0] != "~" and second[0] == "~" and op == "|":
            ans = x1[i] | ~x2[i]
            
        elif first[0] != "~" and second[0] == "~" and op == "&":
            ans = x1[i] & ~x2[i]
            
        elif first[0] == "~" and second[0] != "~" and op == "|":
            ans = ~x1[i] | x2[i]
            
        elif first[0] == "~" and second[0] != "~" and op == "&":
            ans = ~x1[i] & x2[i]
            
        elif first[0] == "~" and second[0] == "~" and op == "|":
            ans = ~x1[i] | ~x2[i]
            
        elif first[0] == "~" and second[0] == "~" and op == "&":
            ans = ~x1[i] & ~x2[i]
            
        y.append(ans)
        
    
    yin = []
    for i in range(0,4):
        ans = w1*x1[i] + w2*x2[i]
        yin.append(ans)
    
    print(x1Header,"       ",x2Header,"       ",yHeader,"       ",yinHeader)
        
    for i in range(0,4):
        print(x1[i],"        ",x2[i],"        ",y[i],"         ",yin[i])
            
            
    print()
    print("And setting theta = ",theta)
    
    
    
    print()
    print(yHeader,"  =  f(",yinHeader,") = { ",f(theta,theta),"   ",yinHeader," >= ", theta)
    print("                   { " ,f(theta-1,theta),"   ",yinHeader," < ", theta)
    
    # line
    print()
    print("*****************************************")
    

makeGate("ANDNOT","x1","&","~x2","x1","x2","z1","z1in",1,-1,1)
makeGate("ANDNOT","~x1","&","x2","x1","x2","z2","z2in",-1,1,1)
makeGate("OR","z1","|","z2","z1","z2","y","yin",1,1,1)

print("So XOR gate can be realised by using MCP model")
</pre>
<hr>
<br>

<strong>Perceptron AND</strong>
<pre>
    import numpy as np

def sigmoid(x):
  return 1/(1+np.exp(-x))

def activation_sigmoid(x):
  y = sigmoid(x)
  if y>0:
    return 1
  elif y==0:
    return 0
  else:
    return -1

def step_function(y):
  if y>0:
    return 1
  elif y==0:
    return 0
  else:
    return -1

w = [0,0]
Wold=[0,0]
b = 0
alpha = 1

x1 = [1,1,-1,-1]
x2 = [1,-1,1,-1]
t = [1,-1,-1,-1]
epoch=True
num=1
while(epoch):
  print("\n Epoch", num ," : ")
  num=num+1
  print("_______________________________________")
  for i in range(4):
    yin = x1[i]*w[0]+x2[i]*w[1]+b
    y = step_function(yin)
    print(y)
    if(y!=t[i]):
      w[0] = w[0] + alpha*t[i]*x1[i]
      w[1] = w[1] + alpha*t[i]*x2[i]
      b = b + alpha*t[i]
      
    print(f'Weights : w1 = {w[0]} , w2 = {w[1]} , b = {b}')
  if(Wold[0]==w[0] and Wold[1]==w[1]):
      epoch=0
  Wold=w

print(f'Weights : w1 = {w[0]} , w2 = {w[1]} , b = {b}')
</pre>
<hr>
<br>

<strong>Adaline OR</strong>
<pre>
    import numpy as np

features = np.array(
    [
        [-1, -1],
        [-1, 1],
        [1, -1],
        [1, 1]
    ])

labels = np.array([-1, 1, 1, 1])

print(features, labels)

weight = [0, 0]
bias = 1
learning_rate = 0.2
epoch = 10

for i in range(epoch):

    print("epoch :", i+1)

    sum_squared_error = 0.0

    for j in range(features.shape[0]):

        actual = labels[j]

        x1 = features[j][0]
        x2 = features[j][1]

        unit = (x1 * weight[0]) + (x2 * weight[1]) + bias

        error = actual - unit

        print("error =", error)

        sum_squared_error += error * error

        weight[0] += learning_rate * error * x1
        weight[1] += learning_rate * error * x2

        bias += learning_rate * error

    print("sum of squared error = ", sum_squared_error/4, "\n\n")

</pre>
<hr>
<br>

<strong>Adaline AND</strong>
<pre>
    import numpy as np

features = np.array(
    [
        [-1, -1],
        [-1, 1],
        [1, -1],
        [1, 1]
    ])

labels = np.array([-1, -1, -1, 1])

print(features, labels)

weight = [0, 0]
bias = 1
learning_rate = 0.2
epoch = 10

for i in range(epoch):

    print("epoch :", i+1)

    sum_squared_error = 0.0

    for j in range(features.shape[0]):

        actual = labels[j]

        x1 = features[j][0]
        x2 = features[j][1]

        unit = (x1 * weight[0]) + (x2 * weight[1]) + bias

        error = actual - unit

        print("error =", error)

        sum_squared_error += error * error

        weight[0] += learning_rate * error * x1
        weight[1] += learning_rate * error * x2

        bias += learning_rate * error

    print("sum of squared error = ", sum_squared_error/4, "\n\n")

</pre>
<hr>
<br>

<strong>Perceptron Tars ANDNOT</strong>
<pre>
    def activation(yin,theta):
    if yin>0:
        return 1
    elif yin &lt; 0:
        return -1
    else:
        return 0

x1 = [1, 1, -1, -1]
x2 = [1, -1, 1, -1]
t = [-1,1,-1,-1]
bias, w1,w2=0,0,0
alpha, theta=1, 0
numEpoch = int(input("Enter number of epochs: "))

for i in range(numEpoch):
    nowtchange =True
    print("For Epoch:", i + 1)
    for j in range(4):
        sum = 0
        sum = sum + x1[j]*w1 + x2[j]*w2
        yin = bias+sum
        y = activation(yin,theta)
        if t[j] != y:
            nowtchange = False
            w1 = w1 + alpha*t[j]*x1[j]
            w2 = w2 + alpha*t[j]*x2[j]
            bias = bias + alpha*t[j]
            print("Updated Weights are")
            print(f'w1: {w1}, w2: {w2}, b: {bias}')
        else:
            print("No change in Weights")
            print(f'w1: {w1}, w2: {w2}, b: {bias}')
    if nowtchange:
        print("***********************No weight change in entire epoch***************************")

        break




</pre>

<strong>Perceptron ANDNOT</strong>
<pre>
    def activationFn(x, theta):
    if x < -theta:
      return -1
    if -theta <= x <= theta:
      return 0
    return 1
  
  
  class Perceptron:
    def __init__(self, N, theta=0, alpha=1):
      self.N = N
      self.weights = [0] * N
      self.bias = 0
      self.theta = theta
      self.alpha = alpha
      self.expectedInOuts = []
  
    def addexpectedInOut(self, inp, out):
      self.expectedInOuts.append([inp, out])
  
    def getNetinp(self, inp):
      netinp = self.bias
      for i in range(len(inp)):
        netinp += inp[i] * self.weights[i]
      return netinp
  
    def getNetOut(self, inp):
      return activationFn(self.getNetinp(inp), self.theta)
  
    # eg - x1 x2 1  t  yin  y 	dw1 dw2 db	w1 w2 b
    def printLine(self, x, t, yin, y, dw, db, w, b):
      def formattedStr(str): return '{:>4}'.format(str)
  
      s = ''
      for val in x:
        s += formattedStr(val)
      s += formattedStr(1)
      s += '  |  '
      s += formattedStr(t)
      s += '  |  '
      s += formattedStr(yin)
      s += '  |  '
      s += formattedStr(y)
      s += '  |  '
      for val in dw:
        s += formattedStr(val)
      s += formattedStr(db)
      s += '  |  '
      for val in w:
        s += formattedStr(val)
      s += formattedStr(b)
  
      print(s)
  
    def train(self):
      changed = True
      epoch = 1
  
      self.printLine(
          ['x{}'.format(i) for i in range(1, self.N + 1)],
          't',
          'yin',
          'y',
          ['dw{}'.format(i) for i in range(1, self.N + 1)],
          'db',
          ['w{}'.format(i) for i in range(1, self.N + 1)],
          'b'
      )
  
      while changed:
        changed = False
        print('EPOCH -', epoch)
  
        for x, t in self.expectedInOuts:
          yin = self.getNetinp(x)
          y = self.getNetOut(x)
          dw = [0] * self.N
          db = 0
          if y != t:
            for i in range(self.N):
              dw[i] = self.alpha * t * x[i]
              self.weights[i] += dw[i]
            db = self.alpha * t
            self.bias += db
            changed = True
  
          self.printLine(x, t, yin, y, dw, db, self.weights, self.bias)
  
        epoch += 1
  
    def test(self, inp):
      return self.getNetOut(inp)
  
  
  andNot = Perceptron(2, theta=0, alpha=1)
  andNot.addexpectedInOut([1, 1], -1)
  andNot.addexpectedInOut([1, -1], 1)
  andNot.addexpectedInOut([-1, 1], -1)
  andNot.addexpectedInOut([-1, -1], -1)
  
  andNot.train()
  print(andNot.weights, andNot.bias)
  
</pre>
<hr>
<br>

<strong>Auto Associative</strong>
<pre>
    from numpy import size

#activation function
def f(yinj):
    if yinj > 0:
        return 1
    else:
        return -1

print("Auto Associative Networks::")

t = int(input("Enter number of input samples: "))
n = int(input("Enter the number of nodes: "))

X = []
for i in range(t):          # A for loop for row entries
    a = list(map(int, input().split()))
    X.append(a)

Y = X

print("Input Vector is")
for i in range(len(X)):
    print(X[i])
print("\n____________________________\n")
print("Output Vector is")
for i in range(len(Y)):
    print(Y[i])

weights = [[0 for _ in range(n)] for _ in range(n)]

# Training Phase
for k in range(t):
    for i in range(n):
        for j in range(n):
            weights[i][j] += X[k][i]*Y[k][j]


print("\n____________________________\n")
print("Weights after Training:")
for i in range(len(weights)):
    print(weights[i])


while(1):
    print("Enter the testing vector: ")
    # Testing Phase
    test = list(map(int, input().split()))

    print("Test Input", test)

    outs = []
    for j in range(n):
        yinj = 0
        for i in range(n):
            yinj += test[i]*weights[i][j]
        yin = f(yinj)
        outs.append(yin)

    print("Testing Output", outs)
    print("\n")


    AUTO ASSOICATVE 
    2
    4
    1 1 -1 1
    1 -1 -1 -1
</pre>


<hr>
<br>

<strong>Heteroassociative</strong>
<pre>
    print("Heteroassociative Networks::")


def f(yinj):
    if yinj > 0:
        return 1
    if yinj == 0:
        return 0
    else:
        return -1


t = int(input("Enter number of input samples: "))
n = int(input("Enter the number of features: "))
n2 = int(input("Enter length of output: "))
X = []
Y = []
for i in range(t):          # A for loop for row entries
    print("input")
    a = list(map(int, input().split()))
    print("output")
    b = list(map(int, input().split()))
    X.append(a)
    Y.append(b)


print("Input Vector is")
for i in range(len(X)):
    print(X[i])
print("\n____________________________\n")
print("Output Vector is")
for i in range(len(Y)):
    print(Y[i])

weights = [[0 for _ in range(n2)] for _ in range(n)]

# Training Phase
for k in range(t):
    for i in range(n):
        for j in range(n2):
            weights[i][j] += X[k][i]*Y[k][j]

print("\n____________________________\n")
print("Weights after Training:")
for i in range(len(weights)):
    print(weights[i])



# Testing Phase
num = int(input("Enter number of test cases: "))
for p in range(num):
    print("Enter the testing vector: ")

    test = list(map(int, input().split()))
    print("Test Input", test)
    outs = []
    for j in range(n2):
        yinj = 0
        for i in range(n):
            yinj += test[i]*weights[i][j]
        yin = f(yinj)
        outs.append(yin)

    print("Testing Output", outs)
    
    
    HETERO ASSOCIATIVE 
    2
    4
    2
    1 1 1 1
    1 -1
    1 -1 1 -1
    -1 1
</pre>

<hr>
<br>

<strong>BAM</strong>
<pre>
    # Import Python Libraries
import numpy as np

# Take two sets of patterns:
# Set A: Input Pattern
# make 6*1 matrix of inputs
x1 = np.array([1, -1,-1,-1]).reshape(1, 4)
x2 = np.array([1,-1,-1,1]).reshape(1, 4)
x3 = np.array([-1,1,-1,-1]).reshape(1, 4)
x4 = np.array([-1,1,1,-1]).reshape(1, 4)

# Set B: Target Pattern
y1 = np.array([1,-1]).reshape(1,2)
y2 = np.array([1,-1]).reshape(1,2)
y3 = np.array([-1, 1]).reshape(1,2)
y4 = np.array([-1, 1]).reshape(1,2)


print("Set A: Input Pattern, Set B: Target Pattern")
print("\nThe input for pattern 1 is")
print(x1)
print("\nThe target for pattern 1 is")
print(y1)
print("\nThe input for pattern 2 is")
print(x2)
print("\nThe target for pattern 2 is")
print(y2)
print("\nThe input for pattern 3 is")
print(x3)
print("\nThe target for pattern 3 is")
print(y3)
print("\nThe input for pattern 4 is")
print(x4)
print("\nThe target for pattern 4 is")
print(y4)

print("\n------------------------------")

# Calculate weight Matrix: W
inputSet = np.concatenate((x1, x2, x3, x4), axis=0)
targetSet = np.concatenate((y1, y2, y3, y4), axis=0)
print("\nWeight matrix:")
weight = np.dot(inputSet.T, targetSet)
print(weight)

print("\n------------------------------")

# Testing Phase
# Test for Input Patterns: Set A
print("\nTesting for input patterns: Set A")


def testInputs(x, weight):

    # Multiply the input pattern with the weight matrix
    # (weight.T X x)
    y = np.dot(x, weight)
    y[y < 0] = -1
    y[y >= 0] = 1
    return np.array(y)


print("\nOutput of input pattern 1")
print(testInputs(x1, weight))
print("\nOutput of input pattern 2")
print(testInputs(x2, weight))
print("\nOutput of input pattern 3")
print(testInputs(x3, weight))
print("\nOutput of input pattern 4")
print(testInputs(x4, weight))

# Test for Target Patterns: Set B
print("\nTesting for target patterns: Set B")


def testTargets(y, weight):

    # Multiply the target pattern with the weight matrix
    # (weight X y)
    x = np.dot(y, weight.T)
    x[x <= 0] = -1
    x[x > 0] = 1
    return np.array(x)


print("\nOutput of target pattern 1")
print(testTargets(y1, weight))
print("\nOutput of target pattern 2")
print(testTargets(y2, weight))
print("\nOutput of target pattern 3")
print(testTargets(y3, weight))
print("\nOutput of target pattern 4")
print(testTargets(y4, weight))

</pre>
<hr>
<br>

<strong>Hopiefied(Tej)</strong>
<pre>
import numpy as np 
print("Input Vector: [1,1,1,-1]") 
ipvector1 = np.array([1,1,1,1,1]).reshape(1,5) 
ipvector2 = np.array([1,-1,-1,1,-1]).reshape(1,5) 
ipvector3 = np.array([-1,1,-1,-1,-1]).reshape(1,5) 

def activation(x): 
    if(x>0): return 1
    else: return 0
w1=np.transpose(ipvector1)*ipvector1
w2=np.transpose(ipvector2)*ipvector2
w3=np.transpose(ipvector3)*ipvector3

w=w1+w2+w3

for i in range(4): 
    for j in range(4): 
        if(i==j): 
            w[i][j]=0 
print("\n Weight Matrix: ")
print(w) 
#converting to binary
ipvector1 = np.array([1,1,1,1,1])
ipvector2 = np.array([1,0,0,1,0])
ipvector3 = np.array([0,1,0,0,0])
# print("Input vector in binary representation: ",ipvector) 
x=np.array([1,1,1,0,1]).reshape(1,5) 
y=x
for i in range(5): 
    yin = x[0][i] + np.dot(y,w[:,i]) 
    print("yin_",i+1,": ",yin) 
    y[0][i]=activation(yin) 
    print("Updated Y :",y) 
    if((y==ipvector1).all()): 
        print("Hence y=input vector x, vector converge") 
        break
    if((y==ipvector2).all()): 
        print("Hence y=input vector x, vector converge") 
        break
    if((y==ipvector3).all()): 
        print("Hence y=input vector x, vector converge") 
        break
</pre>
<hr>
<br>
<strong>Hopiefied (plot)</strong>
<pre>
    
import matplotlib.pyplot as plt
import numpy as np

nb_patterns = 4   # Number of patterns to learn
pattern_width = 5
pattern_height = 5
max_iterations = 10

# Define Patterns
patterns = np.array([
    [1, -1, -1, -1, 1, 1, -1, 1, 1, -1, 1, -1, 1, 1, -1,
        1, -1, 1, 1, -1, 1, -1, -1, -1, 1.],   # Letter D
    [-1, -1, -1, -1, -1, 1, 1, 1, -1, 1, 1, 1, 1, -1, 1, - \
     1, 1, 1, -1, 1, -1, -1, -1, 1, 1.],    # Letter J
    [1, -1, -1, -1, -1, -1, 1, 1, 1, 1, -1, 1, 1, 1, 1, - \
     1, 1, 1, 1, 1, 1, -1, -1, -1, -1.],     # Letter C
    [-1, 1, 1, 1, -1, -1, -1, 1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1.], ],  # Letter M
    dtype=np.float)
fig, ax = plt.subplots(1, nb_patterns, figsize=(15, 10))

for i in range(nb_patterns):
    ax[i].matshow(patterns[i].reshape(
        (pattern_height, pattern_width)), cmap='gray')
    ax[i].set_xticks([])
    ax[i].set_yticks([])
W = np.zeros((pattern_width * pattern_height, pattern_width * pattern_height))

for i in range(pattern_width * pattern_height):
    for j in range(pattern_width * pattern_height):
        if i == j or W[i, j] != 0.0:
            continue

        w = 0.0

        for n in range(nb_patterns):
            w += patterns[n, i] * patterns[n, j]

        W[i, j] = w / patterns.shape[0]
        W[j, i] = W[i, j]
S = np.array([1, -1, -1, -1, -1, 1, 1, 1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, 1, 1, 1, 1, -1, -1, -1.],
             dtype=np.float)

# Show the corrupted pattern
fig, ax = plt.subplots()
ax.matshow(S.reshape((pattern_height, pattern_width)), cmap='gray')
h = np.zeros((pattern_width * pattern_height))
# Defining Hamming Distance matrix for seeing convergence
hamming_distance = np.zeros((max_iterations, nb_patterns))
for iteration in range(max_iterations):
    for i in range(pattern_width * pattern_height):
        i = np.random.randint(pattern_width * pattern_height)
        h[i] = 0
        for j in range(pattern_width * pattern_height):
            h[i] += W[i, j]*S[j]
        S = np.where(h < 0, -1, 1)
    for i in range(nb_patterns):
        hamming_distance[iteration, i] = ((patterns - S)[i] != 0).sum()

    fig, ax = plt.subplots()
    ax.matshow(S.reshape((pattern_height, pattern_width)), cmap='gray')
plt.show()
hamming_distance

</pre>

<hr>
<br>
<strong>Self Organising Maps</strong>
<pre>
    
import matplotlib.pyplot as plt
import numpy as np

nb_patterns = 4   # Number of patterns to learn
pattern_width = 5
pattern_height = 5
max_iterations = 10

# Define Patterns
patterns = np.array([
    [1, -1, -1, -1, 1, 1, -1, 1, 1, -1, 1, -1, 1, 1, -1,
        1, -1, 1, 1, -1, 1, -1, -1, -1, 1.],   # Letter D
    [-1, -1, -1, -1, -1, 1, 1, 1, -1, 1, 1, 1, 1, -1, 1, - \
     1, 1, 1, -1, 1, -1, -1, -1, 1, 1.],    # Letter J
    [1, -1, -1, -1, -1, -1, 1, 1, 1, 1, -1, 1, 1, 1, 1, - \
     1, 1, 1, 1, 1, 1, -1, -1, -1, -1.],     # Letter C
    [-1, 1, 1, 1, -1, -1, -1, 1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1.], ],  # Letter M
    dtype=np.float)
fig, ax = plt.subplots(1, nb_patterns, figsize=(15, 10))

for i in range(nb_patterns):
    ax[i].matshow(patterns[i].reshape(
        (pattern_height, pattern_width)), cmap='gray')
    ax[i].set_xticks([])
    ax[i].set_yticks([])
W = np.zeros((pattern_width * pattern_height, pattern_width * pattern_height))

for i in range(pattern_width * pattern_height):
    for j in range(pattern_width * pattern_height):
        if i == j or W[i, j] != 0.0:
            continue

        w = 0.0

        for n in range(nb_patterns):
            w += patterns[n, i] * patterns[n, j]

        W[i, j] = w / patterns.shape[0]
        W[j, i] = W[i, j]
S = np.array([1, -1, -1, -1, -1, 1, 1, 1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, 1, 1, 1, 1, -1, -1, -1.],
             dtype=np.float)

# Show the corrupted pattern
fig, ax = plt.subplots()
ax.matshow(S.reshape((pattern_height, pattern_width)), cmap='gray')
h = np.zeros((pattern_width * pattern_height))
# Defining Hamming Distance matrix for seeing convergence
hamming_distance = np.zeros((max_iterations, nb_patterns))
for iteration in range(max_iterations):
    for i in range(pattern_width * pattern_height):
        i = np.random.randint(pattern_width * pattern_height)
        h[i] = 0
        for j in range(pattern_width * pattern_height):
            h[i] += W[i, j]*S[j]
        S = np.where(h < 0, -1, 1)
    for i in range(nb_patterns):
        hamming_distance[iteration, i] = ((patterns - S)[i] != 0).sum()

    fig, ax = plt.subplots()
    ax.matshow(S.reshape((pattern_height, pattern_width)), cmap='gray')
plt.show()
hamming_distance

</pre>

<hr>
<br>

<strong>SOM video</strong>
<pre>
    #Self organizing map clustering algorithm
# The Academician
import numpy as np, numpy.random
from scipy.spatial import distance
np.set_printoptions(suppress=True) #Force-suppress all exponential notation

k = 2
p = 0
alpha = 0.7 # Initial learning rate

X = np.array([
        [1,1,0,0], 
        [0,1,0,0], 
        [0,0,1,0], 
        [0,0,1,1]])


# Print the number of data and dimension 
n = len(X)
d = len(X[0])
addZeros = np.zeros((n, 1))
X = np.append(X, addZeros, axis=1)
print("The SOM algorithm: \n")
print("The training data: \n", X)
print("\nTotal number of data: ",n)
print("Total number of features: ",d)
print("Total number of Clusters: ",k)

C = np.zeros((k,d+1))

weight = np.random.rand(n,k)
print("\nThe initial weight: \n", np.round(weight,2))

for it in range(100): # Total number of iterations
    for i in range(n):
        distMin = 99999999
        for j in range(k):
            dist = np.square(distance.euclidean(weight[:,j], X[i,0:d]))
            if distMin>dist:
                distMin = dist
                jMin = j
        weight[:,jMin] = weight[:,jMin]*(1-alpha) + alpha*X[i,0:d]   
    alpha = 0.5*alpha
    
print("\nThe final weight: \n",np.round(weight,4))

for i in range(n):    
    cNumber = np.where(weight[i] == np.amax(weight[i]))
    X[i,d] = cNumber[0]
    
print("\nThe data with cluster number: \n", X)


    
</pre>
    </div>
</body>
</html>
